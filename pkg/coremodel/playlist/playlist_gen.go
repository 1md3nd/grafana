// This file is autogenerated. DO NOT EDIT.
//
// Run "make gen-cue" from repository root to regenerate.
//
// Derived from the Thema lineage at pkg/coremodel/playlist

package playlist

import (
	"embed"
	"path/filepath"

	"github.com/grafana/grafana/pkg/cuectx"
	"github.com/grafana/grafana/pkg/framework/coremodel"
	"github.com/grafana/thema"
)

// Defines values for PlaylistInterval.
const (
	IntervalN5m Interval = "5m"
)

// Defines values for PlaylistName.
const (
	NameEmpty Name = ""
)

// Defines values for PlaylistUid.
const (
	UidEmpty Uid = ""
)

// Defines values for PlaylistItemsType.
const (
	ItemsTypeDashboardById ItemsType = "dashboard_by_id"

	ItemsTypeDashboardByTag ItemsType = "dashboard_by_tag"

	ItemsTypeDashboardByUid ItemsType = "dashboard_by_uid"
)

// Playlist defines model for playlist.
//
// THIS TYPE IS INTENDED FOR INTERNAL USE BY THE GRAFANA BACKEND, AND IS SUBJECT TO BREAKING CHANGES.
// Equivalent Go types at stable import paths are provided in https://github.com/grafana/grok.
type Model struct {
	// Unique numeric identifier for the playlist.
	// TODO: Isolate or remove identifiers local to a Grafana instance
	Id *int64 `json:"id,omitempty"`

	// Interval
	// TODO: Figure out the type of this, and validate that it's how long between shifts between items in the playlist.
	Interval *Interval `json:"interval,omitempty"`
	Items    *Items    `json:"items,omitempty"`

	// Name of the playlist.
	Name *Name `json:"name,omitempty"`

	// Unique playlist identifier. Generated on creation, either by the
	// creator of the playlist of by the application.
	Uid *Uid `json:"uid,omitempty"`
}

// Interval
// TODO: Figure out the type of this, and validate that it's how long between shifts between items in the playlist.
//
// THIS TYPE IS INTENDED FOR INTERNAL USE BY THE GRAFANA BACKEND, AND IS SUBJECT TO BREAKING CHANGES.
// Equivalent Go types at stable import paths are provided in https://github.com/grafana/grok.
type Interval string

// Name of the playlist.
//
// THIS TYPE IS INTENDED FOR INTERNAL USE BY THE GRAFANA BACKEND, AND IS SUBJECT TO BREAKING CHANGES.
// Equivalent Go types at stable import paths are provided in https://github.com/grafana/grok.
type Name string

// Unique playlist identifier. Generated on creation, either by the
// creator of the playlist of by the application.
//
// THIS TYPE IS INTENDED FOR INTERNAL USE BY THE GRAFANA BACKEND, AND IS SUBJECT TO BREAKING CHANGES.
// Equivalent Go types at stable import paths are provided in https://github.com/grafana/grok.
type Uid string

// PlaylistItems defines model for playlist.Items.
//
// THIS TYPE IS INTENDED FOR INTERNAL USE BY THE GRAFANA BACKEND, AND IS SUBJECT TO BREAKING CHANGES.
// Equivalent Go types at stable import paths are provided in https://github.com/grafana/grok.
type Items struct {
	// Unique numeric identifier for the item references by the playlist.
	// TODO: Isolate or remove identifiers local to a Grafana instance
	Id *int64 `json:"id,omitempty"`

	// Order determines the weight of the item when displaying the items.
	// TODO: Docs
	Order *int `json:"order,omitempty"`

	// Title of the playlist item.
	Title *string `json:"title,omitempty"`

	// Type of the item.
	Type *ItemsType `json:"type,omitempty"`

	// Unique identifier for the item references by the playlist.
	Uid *string `json:"uid,omitempty"`

	// TODO: What is this? Is this what's used for dashboard_by_tag?
	Value *string `json:"value,omitempty"`
}

// Type of the item.
//
// THIS TYPE IS INTENDED FOR INTERNAL USE BY THE GRAFANA BACKEND, AND IS SUBJECT TO BREAKING CHANGES.
// Equivalent Go types at stable import paths are provided in https://github.com/grafana/grok.
type ItemsType string

//go:embed coremodel.cue
var cueFS embed.FS

// codegen ensures that this is always the latest Thema schema version
var currentVersion = thema.SV(0, 0)

// Lineage returns the Thema lineage representing a Grafana playlist.
//
// The lineage is the canonical specification of the current playlist schema,
// all prior schema versions, and the mappings that allow migration between
// schema versions.
func Lineage(lib thema.Library, opts ...thema.BindOption) (thema.Lineage, error) {
	return cuectx.LoadGrafanaInstancesWithThema(filepath.Join("pkg", "coremodel", "playlist"), cueFS, lib, opts...)
}

var _ thema.LineageFactory = Lineage
var _ coremodel.Interface = &Coremodel{}

// Coremodel contains the foundational schema declaration for playlists.
// It implements coremodel.Interface.
type Coremodel struct {
	lin thema.Lineage
}

// Lineage returns the canonical playlist Lineage.
func (c *Coremodel) Lineage() thema.Lineage {
	return c.lin
}

// CurrentSchema returns the current (latest) playlist Thema schema.
func (c *Coremodel) CurrentSchema() thema.Schema {
	return thema.SchemaP(c.lin, currentVersion)
}

// GoType returns a pointer to an empty Go struct that corresponds to
// the current Thema schema.
func (c *Coremodel) GoType() interface{} {
	return &Model{}
}

// New returns a new instance of the playlist coremodel.
//
// Note that this function does not cache, and initially loading a Thema lineage
// can be expensive. As such, the Grafana backend should prefer to access this
// coremodel through a registry (pkg/framework/coremodel/registry), which does cache.
func New(lib thema.Library) (*Coremodel, error) {
	lin, err := Lineage(lib)
	if err != nil {
		return nil, err
	}

	return &Coremodel{
		lin: lin,
	}, nil
}
