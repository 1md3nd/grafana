package permissions

import (
	"fmt"
	"sort"
	"strings"

	"github.com/davecgh/go-spew/spew"
	"github.com/grafana/grafana/pkg/services/accesscontrol"
	"github.com/grafana/grafana/pkg/services/dashboards"
	"github.com/grafana/grafana/pkg/services/featuremgmt"
	"github.com/grafana/grafana/pkg/services/folder"
	"github.com/grafana/grafana/pkg/services/login"
	"github.com/grafana/grafana/pkg/services/sqlstore/migrator"
	"github.com/grafana/grafana/pkg/services/user"
)

type refactoredDashboardPermissionFilter struct {
	user             *user.SignedInUser
	dashboardActions []string
	folderActions    []string
	features         featuremgmt.FeatureToggles

	on     []clause
	having []clause

	dialect migrator.Dialect
}

// With implements PermissionsFilter.
func (*refactoredDashboardPermissionFilter) With() (string, []interface{}) {
	return "", nil
}

func (f *refactoredDashboardPermissionFilter) GroupBy() (string, []interface{}) {
	q, params := f.buildClauses()
	return "dashboard.id, p1.role_id, p1.scope HAVING " + q, params
}

func (f *refactoredDashboardPermissionFilter) Where() (string, []interface{}) {
	return "", nil
}

func (f *refactoredDashboardPermissionFilter) LeftJoin() (string, []interface{}) {
	if f.user == nil || f.user.Permissions == nil || f.user.Permissions[f.user.OrgID] == nil {
		return "", nil
	}

	builder := strings.Builder{}
	builder.WriteString("dashboard AS folder ON folder.id = dashboard.folder_id")

	if f.features.IsEnabled(featuremgmt.FlagNestedFolders) {
		builder.WriteString(` LEFT OUTER JOIN folder f0 ON f0.org_id = dashboard.org_id AND (dashboard.uid = f0.uid OR folder.uid = f0.uid)`)
		for i := 1; i <= folder.MaxNestedFolderDepth; i++ {
			builder.WriteString(fmt.Sprintf(` LEFT OUTER JOIN folder f%d ON f%d.org_id = f%d.org_id AND f%d.uid = f%d.parent_uid`, i, i, i-1, i, i-1))
		}
	}

	var args []interface{}
	builder.WriteString(` INNER JOIN permission AS p1 ON dashboard.org_id = ?`)

	userRolesFilterCondition, params := accesscontrol.UserRolesFilterCondition(f.user.OrgID, f.user.UserID)
	if userRolesFilterCondition != "" {
		builder.WriteString(" INNER JOIN user_role AS ur ON ur.role_id = p1.role_id AND ")
		builder.WriteString(userRolesFilterCondition)
		args = append(args, params...)
	}

	teamRolesFilterCondition, teamParams := accesscontrol.TeamRolesFilderCondition(f.user.OrgID, f.user.Teams)
	if teamRolesFilterCondition != "" {
		builder.WriteString(" INNER JOIN team_role AS tr ON tr.role_id = p1.role_id AND ")
		builder.WriteString(teamRolesFilterCondition)
		args = append(args, teamParams...)
	}

	builtinRolesFilterCondition, builtinParams := accesscontrol.BuiltinRolesFilterCondition(f.user.OrgID, accesscontrol.GetOrgRoles(f.user))
	if builtinRolesFilterCondition != "" {
		builder.WriteString(" INNER JOIN builtin_role AS br ON br.role_id = p1.role_id AND ")
		builder.WriteString(builtinRolesFilterCondition)
		args = append(args, builtinParams...)
	}

	return builder.String(), append([]interface{}{f.user.OrgID}, args...)
}

func (f *refactoredDashboardPermissionFilter) buildScope(prefix, col string) string {
	return f.dialect.Concat(fmt.Sprintf("'%s'", prefix), col)
}

func (f *refactoredDashboardPermissionFilter) buildFolderScope(col string) string {
	return f.buildScope(dashboards.ScopeFoldersPrefix, col)
}

func (f *refactoredDashboardPermissionFilter) buildDashboardScope(col string) string {
	return f.buildScope(dashboards.ScopeDashboardsPrefix, col)
}

func (f *refactoredDashboardPermissionFilter) buildClauses() (string, []interface{}) {
	if f.user == nil || f.user.Permissions == nil || f.user.Permissions[f.user.OrgID] == nil {
		return "(1 = 0)", nil
	}
	dashWildcards := accesscontrol.WildcardsFromPrefix(dashboards.ScopeDashboardsPrefix)
	folderWildcards := accesscontrol.WildcardsFromPrefix(dashboards.ScopeFoldersPrefix)

	var args []interface{}
	builder := strings.Builder{}
	builder.WriteRune('(')

	permSelector := strings.Builder{}
	var permSelectorArgs []interface{}

	// useSelfContainedPermissions is true if the user's permissions are stored and set from the JWT token
	// currently it's used for the extended JWT module (when the user is authenticated via a JWT token generated by Grafana)
	useSelfContainedPermissions := f.user.AuthenticatedBy == login.ExtendedJWTModule

	spew.Dump(">>>> . ", f.dashboardActions, f.folderActions)

	if len(f.dashboardActions) > 0 {
		toCheck := actionsToCheckStr(f.dashboardActions, f.user.Permissions[f.user.OrgID], dashWildcards, folderWildcards)

		if len(toCheck) > 0 {
			if !useSelfContainedPermissions {
				builder.WriteString("(" + f.buildDashboardScope("dashboard.uid") + " = p1.scope AND ")

				var s string
				var arg string
				if len(toCheck) == 1 {
					s = " p1.action = ? "
					arg = toCheck[0]

				} else {
					s = " GROUP_CONCAT(p1.action) = ? "
					arg = strings.Join(toCheck, ",")
				}
				builder.WriteString(s)
				args = append(args, arg)

				permSelector.WriteString(s)
				permSelectorArgs = append(permSelectorArgs, arg)
				builder.WriteString(" AND NOT dashboard.is_folder)")
				builder.WriteString(" OR ")

				switch f.features.IsEnabled(featuremgmt.FlagNestedFolders) {
				case true:
					builder.WriteRune('(')
					for i := 0; i <= folder.MaxNestedFolderDepth; i++ {
						if i > 0 {
							builder.WriteString(" OR ")
						}
						builder.WriteString(f.buildFolderScope(fmt.Sprintf("f%d.uid", i)) + " = p1.scope AND " + permSelector.String())
						args = append(args, permSelectorArgs...)
					}
					builder.WriteString(") AND NOT dashboard.is_folder")

				default:
					builder.WriteString("(" + f.buildFolderScope("folder.uid") + " = p1.scope AND " + permSelector.String() + " AND NOT dashboard.is_folder)")
					args = append(args, permSelectorArgs...)
				}
			} else {
				actions := parseStringSliceFromInterfaceSliceStr(toCheck)

				args = getAllowedUIDs(actions, f.user, dashboards.ScopeDashboardsPrefix)

				// Only add the IN clause if we have any dashboards to check
				if len(args) > 0 {
					builder.WriteString("(dashboard.uid IN (?" + strings.Repeat(", ?", len(args)-1) + ") AND NOT dashboard.is_folder)")
				} else {
					builder.WriteString("(1 = 0)")
				}
				builder.WriteString(" OR ")

				permSelectorArgs = getAllowedUIDs(actions, f.user, dashboards.ScopeFoldersPrefix)

				// Only add the IN clause if we have any folders to check
				if len(permSelectorArgs) > 0 {
					permSelector.WriteString("(?" + strings.Repeat(", ?", len(permSelectorArgs)-1) + "")
				} else {
					permSelector.WriteString("(")
				}
				permSelector.WriteRune(')')
				switch f.features.IsEnabled(featuremgmt.FlagNestedFolders) {
				case true:
					nestedFoldersSelectors, nestedFoldersArgs := nestedFoldersSelectors(permSelector.String(), permSelectorArgs, "folder_id", "id")
					builder.WriteRune('(')
					builder.WriteString(nestedFoldersSelectors)
					args = append(args, nestedFoldersArgs...)
				default:
					builder.WriteString("(dashboard.folder_id IN (SELECT d.id FROM dashboard as d ")
					if len(permSelectorArgs) > 0 {
						builder.WriteString("WHERE d.uid IN ")
						builder.WriteString(permSelector.String())
						args = append(args, permSelectorArgs...)
						builder.WriteString(") AND NOT dashboard.is_folder)")
					} else {
						builder.WriteString("WHERE 1 = 0 AND NOT dashboard.is_folder)")
					}
				}
			}
		} else {
			builder.WriteString("NOT dashboard.is_folder")
		}
	}

	// recycle and reuse
	permSelector.Reset()
	permSelectorArgs = permSelectorArgs[:0]

	if len(f.folderActions) > 0 {
		if len(f.dashboardActions) > 0 {
			builder.WriteString(" OR ")
		}

		toCheck := actionsToCheckStr(f.folderActions, f.user.Permissions[f.user.OrgID], folderWildcards)
		if len(toCheck) > 0 {
			if !useSelfContainedPermissions {
				if len(toCheck) == 1 {
					permSelector.WriteString(" p1.action = ?")
					permSelectorArgs = append(permSelectorArgs, toCheck[0])
				} else {
					permSelector.WriteString(" GROUP_CONCAT(p1.action) = ?")
					permSelectorArgs = append(permSelectorArgs, strings.Join(toCheck, ","))
				}

				switch f.features.IsEnabled(featuremgmt.FlagNestedFolders) {
				case true:
					builder.WriteRune('(')
					for i := 0; i <= folder.MaxNestedFolderDepth; i++ {
						if i > 0 {
							builder.WriteString(" OR ")
						}
						builder.WriteString(f.buildFolderScope(fmt.Sprintf("f%d.uid", i)) + " = p1.scope AND " + permSelector.String())
						args = append(args, permSelectorArgs...)
					}
					builder.WriteString(") AND dashboard.is_folder")
				default:
					builder.WriteString("(" + f.buildFolderScope("dashboard.uid") + " = p1.scope AND " + permSelector.String() + " AND dashboard.is_folder)")
					args = append(args, permSelectorArgs...)
				}
			} else {
				actions := parseStringSliceFromInterfaceSliceStr(toCheck)

				permSelectorArgs = getAllowedUIDs(actions, f.user, dashboards.ScopeFoldersPrefix)

				if len(permSelectorArgs) > 0 {
					permSelector.WriteString("(?" + strings.Repeat(", ?", len(permSelectorArgs)-1) + "")
				} else {
					permSelector.WriteString("(")
				}
				permSelector.WriteRune(')')
				switch f.features.IsEnabled(featuremgmt.FlagNestedFolders) {
				case true:
					nestedFoldersSelectors, nestedFoldersArgs := nestedFoldersSelectors(permSelector.String(), permSelectorArgs, "uid", "uid")
					builder.WriteRune('(')
					builder.WriteString(nestedFoldersSelectors)
					builder.WriteRune(')')
					args = append(args, nestedFoldersArgs...)
				default:
					if len(permSelectorArgs) > 0 {
						builder.WriteString("(dashboard.uid IN ")
						builder.WriteString(permSelector.String())
						args = append(args, permSelectorArgs...)
					} else {
						builder.WriteString("(1 = 0")
					}
				}
				builder.WriteString(" AND dashboard.is_folder)")
			}

		} else {
			builder.WriteString("dashboard.is_folder")
		}
	}

	builder.WriteRune(')')

	return builder.String(), args
}

func actionsToCheckStr(actions []string, permissions map[string][]string, wildcards ...accesscontrol.Wildcards) []string {
	toCheck := make([]string, 0, len(actions))

	for _, a := range actions {
		var hasWildcard bool

	outer:
		for _, scope := range permissions[a] {
			for _, w := range wildcards {
				if w.Contains(scope) {
					hasWildcard = true
					break outer
				}
			}
		}

		if !hasWildcard {
			toCheck = append(toCheck, a)
		}
	}
	sort.Strings(toCheck)

	return toCheck
}

func parseStringSliceFromInterfaceSliceStr(slice []string) []string {
	result := make([]string, 0, len(slice))
	for _, s := range slice {
		result = append(result, s)
	}
	return result
}
